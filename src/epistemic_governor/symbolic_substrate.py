"""
Symbolic Substrate (V2)

This is the authoritative state layer. Language is a proposal mechanism;
this is where legitimacy lives.

Core inversion:
- V1 (extractor, normalizer, router) produces candidate commitments Φ̂
- V2 (this module) adjudicates and maintains symbolic state S_t
- Language output is an untrusted projection P(S_t) → y

Key invariants:
1. No confidence creation - σ mass is conserved unless external evidence arrives
2. Authority separation - model proposes, governor commits, self-certification illegal
3. Epistemic continuity - prior claims persist, contradictions can't be smoothed rhetorically

Architecture:
    S_t = ⟨E_t, R_t, Φ_t, Θ, K⟩
    
    Where:
    - E_t: entity registry
    - R_t: typed relations
    - Φ_t: commitment store (first-class objects)
    - Θ: time structure (three clocks)
    - K: compression/decay policy
"""

from dataclasses import dataclass, field
from typing import (
    Dict, List, Set, Optional, Tuple, Any, 
    Union, FrozenSet, Literal,
)
from enum import Enum, auto
from datetime import datetime
import hashlib
import json


# =============================================================================
# Predicates (Non-Stringly Typed)
# =============================================================================

class PredicateType(Enum):
    """
    Core predicate types. Not strings - actual typed relations.
    
    These are the only valid predicate forms in the symbolic substrate.
    Anything else must be mapped to these or rejected.
    """
    # Entity predicates
    HAS = auto()          # Has(entity, property, value)
    IS_A = auto()         # IsA(entity, type)
    SAME_AS = auto()      # SameAs(entity1, entity2) - identity with uncertainty
    
    # Temporal predicates
    BEFORE = auto()       # Before(event1, event2)
    DURING = auto()       # During(event, interval)
    AT_TIME = auto()      # AtTime(entity, property, value, time)
    
    # Relational predicates
    CAUSES = auto()       # Causes(event1, event2)
    PART_OF = auto()      # PartOf(entity, whole)
    LOCATED_AT = auto()   # LocatedAt(entity, location, time?)
    
    # Meta predicates
    DEPENDS_ON = auto()   # DependsOn(commitment1, commitment2) - logical dependency
    SUPPORTS = auto()     # Supports(evidence, commitment) - evidentiary dependency
    CONTRADICTS = auto()  # Contradicts(commitment1, commitment2)


@dataclass(frozen=True)
class Predicate:
    """
    A typed predicate instance.
    
    Predicates are immutable and hashable. They form the structural
    backbone of commitments.
    """
    ptype: PredicateType
    args: Tuple[str, ...]  # Entity/value references
    
    def __post_init__(self):
        # Validate arity
        expected_arity = {
            PredicateType.HAS: 3,
            PredicateType.IS_A: 2,
            PredicateType.SAME_AS: 2,
            PredicateType.BEFORE: 2,
            PredicateType.DURING: 2,
            PredicateType.AT_TIME: 4,
            PredicateType.CAUSES: 2,
            PredicateType.PART_OF: 2,
            PredicateType.LOCATED_AT: (2, 3),  # Optional time
            PredicateType.DEPENDS_ON: 2,
            PredicateType.SUPPORTS: 2,
            PredicateType.CONTRADICTS: 2,
        }
        expected = expected_arity.get(self.ptype)
        if isinstance(expected, tuple):
            if len(self.args) not in expected:
                raise ValueError(f"{self.ptype.name} expects {expected} args, got {len(self.args)}")
        elif expected and len(self.args) != expected:
            raise ValueError(f"{self.ptype.name} expects {expected} args, got {len(self.args)}")
    
    def canonical_form(self) -> str:
        """Canonical string for hashing."""
        return f"{self.ptype.name}({','.join(self.args)})"


# =============================================================================
# Provenance Classes
# =============================================================================

class ProvenanceClass(Enum):
    """
    Where did the evidence come from?
    
    Different provenance classes have different reliability priors
    and support mass multipliers.
    """
    CITED = auto()       # External citation (URL, DOI, document)
    SENSOR = auto()      # Direct observation (API, database, tool output)
    INFERRED = auto()    # Derived from other commitments
    MODEL = auto()       # Generated by LLM (lowest trust)
    USER = auto()        # Asserted by user (trust configurable)
    SYSTEM = auto()      # System policy/configuration


# Provenance reliability priors (tunable)
PROVENANCE_PRIORS = {
    ProvenanceClass.SENSOR: 0.95,
    ProvenanceClass.CITED: 0.80,
    ProvenanceClass.USER: 0.70,
    ProvenanceClass.SYSTEM: 0.99,
    ProvenanceClass.INFERRED: 0.60,
    ProvenanceClass.MODEL: 0.30,
}

# Support mass multiplier by provenance class (a_p in S_min formula)
PROVENANCE_SUPPORT_MULTIPLIER = {
    ProvenanceClass.SENSOR: 0.5,   # Needs less support
    ProvenanceClass.CITED: 1.0,    # Baseline
    ProvenanceClass.USER: 1.2,     # Needs more support
    ProvenanceClass.SYSTEM: 0.3,   # System claims are cheap
    ProvenanceClass.INFERRED: 1.5, # Inferences need more backing
    ProvenanceClass.MODEL: 2.5,    # Model claims need much more
}


# =============================================================================
# Support Items (Evidence)
# =============================================================================

@dataclass(frozen=True)
class SupportItem:
    """
    A single piece of evidence supporting a commitment.
    
    Support items are bucketed by source to prevent citation stacking
    from the same origin.
    """
    source_type: Literal["doc_span", "citation", "sensor", "inference", "user_assertion"]
    source_id: str           # Document ID, URL domain, sensor ID, etc.
    reliability: float       # 0-1, how reliable is this source
    span_text: str = ""      # Optional: the actual text/data
    timestamp: Optional[datetime] = None
    
    @property
    def bucket_key(self) -> str:
        """
        Bucket key for independence checking.
        
        Multiple items from same bucket contribute with diminishing returns.
        """
        if self.source_type == "citation":
            # URLs bucket by domain
            return f"url:{self.source_id.split('/')[0]}"
        elif self.source_type == "doc_span":
            return f"doc:{self.source_id}"
        elif self.source_type == "sensor":
            return f"sensor:{self.source_id}"
        else:
            return f"{self.source_type}:{self.source_id}"


# =============================================================================
# Temporal Scope
# =============================================================================

@dataclass(frozen=True)
class TemporalScope:
    """
    When is this commitment valid?
    
    None means "unknown" - which is legal and better than hallucinating.
    """
    start: Optional[datetime] = None
    end: Optional[datetime] = None
    granularity: Literal["instant", "interval", "unknown"] = "unknown"
    
    @property
    def is_bounded(self) -> bool:
        return self.start is not None or self.end is not None
    
    @property
    def is_point(self) -> bool:
        return self.start == self.end and self.start is not None


# =============================================================================
# Dependency Types (Evidentiary vs Logical)
# =============================================================================

class DependencyType(Enum):
    """
    Two kinds of dependencies - kept separate because they propagate differently.
    """
    LOGICAL = auto()      # φ₁ entails φ₂ - if φ₁ falls, φ₂ falls
    EVIDENTIARY = auto()  # φ₁ supports φ₂ - if φ₁ weakens, φ₂ loses support mass


@dataclass(frozen=True)
class Dependency:
    """A typed dependency between commitments."""
    source_id: str         # Commitment ID this depends on
    dep_type: DependencyType
    weight: float = 1.0    # How much support/entailment flows through


# =============================================================================
# Commitment (The Core Object)
# =============================================================================

@dataclass
class Commitment:
    """
    A first-class epistemic commitment.
    
    This is the unit of belief in the symbolic substrate. Commitments:
    - Have typed predicates (not strings)
    - Carry strength (σ) that must be funded by evidence
    - Have explicit temporal scope
    - Track both logical and evidentiary dependencies
    - Are immutable once accepted (can only be superseded/retracted)
    
    Strength σ is NOT confidence in truth. It's the system's commitment
    level - how much epistemic mass is allocated to this claim.
    """
    # Identity
    commitment_id: str
    
    # Content (what is being claimed)
    predicate: Predicate
    
    # Strength and scope
    sigma: float                    # Commitment strength 0-1
    t_scope: TemporalScope          # When is this valid
    
    # Provenance
    provclass: ProvenanceClass
    support: List[SupportItem] = field(default_factory=list)
    
    # Dependencies (kept separate by type)
    logical_deps: List[Dependency] = field(default_factory=list)
    evidentiary_deps: List[Dependency] = field(default_factory=list)
    
    # Lifecycle
    status: Literal["active", "superseded", "retracted", "quarantined"] = "active"
    created_at: datetime = field(default_factory=datetime.utcnow)
    superseded_by: Optional[str] = None
    
    # Computed (filled by adjudicator)
    support_mass: float = 0.0
    support_deficit: float = 0.0
    
    def canonical_hash(self) -> str:
        """Hash for identity comparison."""
        canonical = json.dumps({
            "predicate": self.predicate.canonical_form(),
            "t_scope": (
                self.t_scope.start.isoformat() if self.t_scope.start else None,
                self.t_scope.end.isoformat() if self.t_scope.end else None,
            ),
        }, sort_keys=True)
        return hashlib.sha256(canonical.encode()).hexdigest()[:16]


# =============================================================================
# Candidate Commitment (Proposal from V1)
# =============================================================================

@dataclass
class CandidateCommitment:
    """
    A proposed commitment from the ingestion layer (V1).
    
    This is what the language model (via V1 extraction) proposes.
    It becomes a real Commitment only if the Adjudicator accepts it.
    """
    predicate: Predicate
    sigma: float                    # Proposed strength
    t_scope: TemporalScope
    provclass: ProvenanceClass
    support: List[SupportItem] = field(default_factory=list)
    logical_deps: List[str] = field(default_factory=list)      # IDs of existing commitments
    evidentiary_deps: List[str] = field(default_factory=list)  # IDs of existing commitments
    
    # Metadata from V1
    source_span: Tuple[int, int] = (0, 0)
    source_text: str = ""
    extraction_confidence: float = 1.0


# =============================================================================
# Three Clocks (Θ)
# =============================================================================

@dataclass
class TemporalState:
    """
    The three-clock time structure.
    
    Δt₁ (fast): Working memory, reactive processing
    Δt₂ (integrative): Belief stabilization, error correction  
    Δt₃ (developmental): Identity, values, structural priors
    
    These advance at different rates and under different conditions.
    """
    # Fast time - advances every turn
    t_fast: int = 0
    
    # Integrative time - advances when beliefs stabilize or contradictions resolve
    t_integrative: int = 0
    
    # Developmental time - advances only under sustained pressure or trauma
    t_developmental: int = 0
    
    # Counters for advancement decisions
    turns_since_integrative: int = 0
    contradiction_pressure: float = 0.0
    stability_streak: int = 0
    
    def tick_fast(self):
        """Called every turn."""
        self.t_fast += 1
        self.turns_since_integrative += 1
    
    def maybe_tick_integrative(self, contradiction_resolved: bool, stability: float) -> bool:
        """
        Integrative time advances when:
        - Contradictions are resolved, OR
        - Stability maintained for N turns
        """
        if contradiction_resolved:
            self.t_integrative += 1
            self.turns_since_integrative = 0
            self.stability_streak = 0
            return True
        
        if stability > 0.8:
            self.stability_streak += 1
            if self.stability_streak >= 5:  # Configurable
                self.t_integrative += 1
                self.turns_since_integrative = 0
                self.stability_streak = 0
                return True
        else:
            self.stability_streak = 0
        
        return False
    
    def maybe_tick_developmental(self, trauma: bool, sustained_pressure_turns: int) -> bool:
        """
        Developmental time advances only under:
        - Trauma (forced write-through), OR
        - Sustained integrative pressure (many t_integrative ticks without resolution)
        """
        if trauma:
            self.t_developmental += 1
            return True
        
        # Sustained pressure threshold (configurable)
        if sustained_pressure_turns >= 20:
            self.t_developmental += 1
            return True
        
        return False


# =============================================================================
# Adjudication Results
# =============================================================================

class AdjudicationDecision(Enum):
    """
    What the adjudicator decided.
    
    These are typed decision codes, not strings.
    """
    ACCEPT = auto()              # Commitment accepted into state
    
    # Schema/structural rejections (phase 1-3)
    REJECT_SCHEMA = auto()              # Invalid predicate schema
    REJECT_CONTRADICTION = auto()       # Contradicts existing commitment
    REJECT_SCOPE_INVALID = auto()       # Temporal scope violation
    REJECT_DEPENDENCY_MISSING = auto()  # Required dependency not in state
    
    # Support rejections (phase 4)
    REJECT_SUPPORT_DEFICIT = auto()    # σ too high for available support
    
    # Quarantine (not rejected, but needs more)
    QUARANTINE_SCHEMA = auto()          # Ambiguous predicate mapping
    QUARANTINE_SUPPORT = auto()         # Support deficit, but not fatal
    QUARANTINE_SCOPE = auto()           # Scope unclear, needs resolution
    QUARANTINE_IDENTITY = auto()        # SameAs uncertainty too high
    
    # Deferred
    DEFER_EVIDENCE_NEEDED = auto()      # Cannot decide without more evidence


@dataclass
class AdjudicationResult:
    """
    Full result of adjudicating a candidate commitment.
    """
    decision: AdjudicationDecision
    candidate: CandidateCommitment
    
    # If accepted, the minted commitment
    commitment: Optional[Commitment] = None
    
    # Support accounting
    support_mass_computed: float = 0.0
    support_mass_required: float = 0.0
    support_deficit: float = 0.0
    
    # Contradiction info
    contradicts: List[str] = field(default_factory=list)  # Commitment IDs
    
    # Dependency resolution
    missing_deps: List[str] = field(default_factory=list)
    
    # Explanation (structured, not prose)
    reason_code: str = ""
    details: Dict[str, Any] = field(default_factory=dict)


# =============================================================================
# Symbolic State S_t
# =============================================================================

@dataclass
class SymbolicState:
    """
    The authoritative symbolic state.
    
    S_t = ⟨E_t, R_t, Φ_t, Θ, K⟩
    
    This is where legitimacy lives. Language is just a view.
    """
    # Entity registry
    entities: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    
    # Commitment store (the core)
    commitments: Dict[str, Commitment] = field(default_factory=dict)
    
    # Indexes for fast lookup
    by_predicate_type: Dict[PredicateType, Set[str]] = field(default_factory=dict)
    by_entity: Dict[str, Set[str]] = field(default_factory=dict)
    
    # Time structure
    theta: TemporalState = field(default_factory=TemporalState)
    
    # Contradiction graph (explicit edges)
    contradictions: List[Tuple[str, str, float]] = field(default_factory=list)  # (id1, id2, severity)
    
    # Global sigma budget (conservation law)
    total_sigma_allocated: float = 0.0
    sigma_budget: float = 100.0  # Configurable cap
    
    # Compression policy K (stub for now)
    decay_half_life: float = 10.0  # Turns until sigma halves without refresh
    
    def register_entity(self, entity_id: str, metadata: Dict[str, Any] = None):
        """Register an entity in the substrate."""
        if entity_id not in self.entities:
            self.entities[entity_id] = metadata or {}
    
    def add_commitment(self, commitment: Commitment):
        """Add an accepted commitment to state."""
        self.commitments[commitment.commitment_id] = commitment
        
        # Update indexes
        ptype = commitment.predicate.ptype
        if ptype not in self.by_predicate_type:
            self.by_predicate_type[ptype] = set()
        self.by_predicate_type[ptype].add(commitment.commitment_id)
        
        for arg in commitment.predicate.args:
            if arg not in self.by_entity:
                self.by_entity[arg] = set()
            self.by_entity[arg].add(commitment.commitment_id)
        
        # Update sigma budget
        self.total_sigma_allocated += commitment.sigma
    
    def get_commitments_for_entity(self, entity_id: str) -> List[Commitment]:
        """Get all commitments involving an entity."""
        if entity_id not in self.by_entity:
            return []
        return [self.commitments[cid] for cid in self.by_entity[entity_id] 
                if cid in self.commitments]
    
    def get_active_commitments(self) -> List[Commitment]:
        """Get all active (non-superseded, non-retracted) commitments."""
        return [c for c in self.commitments.values() if c.status == "active"]


# =============================================================================
# Adjudicator A(S_t, Φ̂)
# =============================================================================

class Adjudicator:
    """
    The adjudication gate.
    
    A(S_t, Φ̂) → {accept, reject, quarantine}
    
    Language cannot bypass this. Ever.
    
    The adjudicator enforces:
    1. Support mass requirements (σ must be funded)
    2. Contradiction detection
    3. Dependency resolution
    4. Scope validity
    5. Sigma budget conservation
    """
    
    def __init__(self, config: Dict[str, Any] = None):
        self.config = config or {}
        
        # Thresholds (tunable)
        self.sigma_hard_gate = self.config.get("sigma_hard_gate", 0.7)
        self.quarantine_threshold = self.config.get("quarantine_threshold", 0.5)
        self.support_deficit_tolerance = self.config.get("support_deficit_tolerance", 0.3)
    
    def adjudicate(
        self, 
        state: SymbolicState, 
        candidate: CandidateCommitment
    ) -> AdjudicationResult:
        """
        Main adjudication entry point.
        
        This is the gate. Nothing gets into state without passing through here.
        
        ORDER MATTERS - this sequence prevents exploits:
        1. Schema validation / typing
        2. Authority checks (self-cert / bypass attempts)
        3. Structural conflict checks (contradiction, scope clash, functional property)
        4. Support calculus (sufficiency, saturation, independence)
        5. Decision + event emission
        
        Contradictions are STRUCTURAL, not evidentiary. Even a low-support
        candidate should trigger "this conflicts with committed state" because
        that's a risk signal, not a truth claim.
        """
        # Compute support mass upfront (needed for result, but not for ordering)
        support_mass = self._compute_support_mass(candidate)
        support_required = self._compute_required_support(candidate.sigma, candidate.provclass)
        support_deficit = max(0, support_required - support_mass)
        
        # -----------------------------------------------------------------
        # Step 1: Schema validation
        # -----------------------------------------------------------------
        schema_valid, schema_reason = self._check_schema(candidate)
        if not schema_valid:
            return AdjudicationResult(
                decision=AdjudicationDecision.REJECT_SCOPE_INVALID,
                candidate=candidate,
                reason_code=schema_reason,
                details={"phase": "schema_validation"},
            )
        
        # -----------------------------------------------------------------
        # Step 2: Authority checks (placeholder for self-cert detection)
        # -----------------------------------------------------------------
        # TODO: Add self-certification detection, bypass attempt detection
        
        # -----------------------------------------------------------------
        # Step 3: Structural conflict checks - BEFORE support!
        # -----------------------------------------------------------------
        
        # 3a: Check dependencies (structural requirement)
        missing_logical = self._check_dependencies(state, candidate.logical_deps)
        if missing_logical:
            return AdjudicationResult(
                decision=AdjudicationDecision.REJECT_DEPENDENCY_MISSING,
                candidate=candidate,
                missing_deps=missing_logical,
                reason_code="LOGICAL_DEPENDENCY_MISSING",
                details={"phase": "structural_conflict"},
            )
        
        # 3b: Check contradictions - this is structural, not evidentiary!
        contradictions = self._find_contradictions(state, candidate)
        if contradictions:
            return AdjudicationResult(
                decision=AdjudicationDecision.REJECT_CONTRADICTION,
                candidate=candidate,
                contradicts=contradictions,
                reason_code="CONTRADICTS_EXISTING",
                support_mass_computed=support_mass,
                support_mass_required=support_required,
                details={"phase": "structural_conflict"},
            )
        
        # 3c: Check scope validity (structural)
        scope_valid, scope_reason = self._check_scope(state, candidate)
        if not scope_valid:
            return AdjudicationResult(
                decision=AdjudicationDecision.QUARANTINE_SCOPE,
                candidate=candidate,
                reason_code=scope_reason,
                details={"phase": "structural_conflict"},
            )
        
        # -----------------------------------------------------------------
        # Step 4: Support calculus - AFTER structural checks
        # -----------------------------------------------------------------
        
        # 4a: Check sigma budget (conservation law)
        if state.total_sigma_allocated + candidate.sigma > state.sigma_budget:
            return AdjudicationResult(
                decision=AdjudicationDecision.REJECT_SUPPORT_DEFICIT,
                candidate=candidate,
                support_mass_computed=support_mass,
                support_mass_required=support_required,
                support_deficit=support_deficit,
                reason_code="SIGMA_BUDGET_EXCEEDED",
                details={"budget": state.sigma_budget, "allocated": state.total_sigma_allocated},
            )
        
        # 4b: Check support deficit (hard gate for high sigma)
        if candidate.sigma >= self.sigma_hard_gate and support_deficit > 0:
            return AdjudicationResult(
                decision=AdjudicationDecision.REJECT_SUPPORT_DEFICIT,
                candidate=candidate,
                support_mass_computed=support_mass,
                support_mass_required=support_required,
                support_deficit=support_deficit,
                reason_code="SUPPORT_DEFICIT_HIGH_SIGMA",
            )
        
        # 4c: Quarantine for moderate support deficit
        if support_deficit > self.support_deficit_tolerance:
            return AdjudicationResult(
                decision=AdjudicationDecision.QUARANTINE_SUPPORT,
                candidate=candidate,
                support_mass_computed=support_mass,
                support_mass_required=support_required,
                support_deficit=support_deficit,
                reason_code="SUPPORT_DEFICIT_QUARANTINE",
            )
        
        # -----------------------------------------------------------------
        # Step 5: Accept - mint commitment
        # -----------------------------------------------------------------
        commitment = self._mint_commitment(candidate, support_mass, support_deficit)
        
        return AdjudicationResult(
            decision=AdjudicationDecision.ACCEPT,
            candidate=candidate,
            commitment=commitment,
            support_mass_computed=support_mass,
            support_mass_required=support_required,
            support_deficit=support_deficit,
            reason_code="ACCEPTED",
        )
    
    def _check_schema(self, candidate: CandidateCommitment) -> Tuple[bool, str]:
        """
        Validate predicate schema.
        
        Returns (is_valid, reason_if_invalid)
        """
        # Check predicate arity is correct (already enforced by Predicate.__post_init__)
        # Check for UNKNOWN args that indicate mapping failure
        unknown_count = sum(1 for arg in candidate.predicate.args if arg == "UNKNOWN")
        if unknown_count > 1:
            return False, "SCHEMA_TOO_MANY_UNKNOWNS"
        
        return True, ""
    
    def _compute_support_mass(self, candidate: CandidateCommitment) -> float:
        """
        Compute support mass with bucket saturation.
        
        Multiple items from same bucket contribute with diminishing returns
        via exponential saturation: M̃ = 1 - e^(-M)
        """
        import math
        
        # Group by bucket
        buckets: Dict[str, float] = {}
        
        for item in candidate.support:
            bucket = item.bucket_key
            # Mass contribution: coverage * g(reliability), where g(r) = r²
            mass = 1.0 * (item.reliability ** 2)
            buckets[bucket] = buckets.get(bucket, 0) + mass
        
        # Apply saturation to each bucket, then sum
        total_mass = 0.0
        for bucket, raw_mass in buckets.items():
            saturated = 1 - math.exp(-raw_mass)
            total_mass += saturated
        
        return total_mass
    
    def _compute_required_support(self, sigma: float, provclass: ProvenanceClass) -> float:
        """
        Compute required support mass for given σ.
        
        S_min(σ) = a_p * σ² / (1 - σ + 0.02)
        
        High σ requires disproportionately more evidence.
        """
        a_p = PROVENANCE_SUPPORT_MULTIPLIER.get(provclass, 1.0)
        if sigma >= 1.0:
            sigma = 0.99  # Avoid division by zero
        return a_p * (sigma ** 2) / (1 - sigma + 0.02)
    
    def _check_dependencies(
        self, 
        state: SymbolicState, 
        dep_ids: List[str]
    ) -> List[str]:
        """Check which dependencies are missing from state."""
        missing = []
        for dep_id in dep_ids:
            if dep_id not in state.commitments:
                missing.append(dep_id)
            elif state.commitments[dep_id].status != "active":
                missing.append(dep_id)
        return missing
    
    def _find_contradictions(
        self, 
        state: SymbolicState, 
        candidate: CandidateCommitment
    ) -> List[str]:
        """
        Find commitments that contradict the candidate.
        
        Contradiction rules by predicate type:
        - AT_TIME: same entity + same property + different value
        - HAS: same entity + same property + different value (for functional properties)
        - LOCATED_AT: same entity + different location + overlapping time
        - IS_A: generally additive, not contradictory
        - SAME_AS: asymmetric, needs special handling
        """
        contradictions = []
        
        for cid, existing in state.commitments.items():
            if existing.status != "active":
                continue
            
            # Must be same predicate type
            if existing.predicate.ptype != candidate.predicate.ptype:
                continue
            
            # Must involve same primary entity (args[0])
            if len(existing.predicate.args) == 0 or len(candidate.predicate.args) == 0:
                continue
            if existing.predicate.args[0] != candidate.predicate.args[0]:
                continue
            
            # Type-specific contradiction detection
            ptype = candidate.predicate.ptype
            
            if ptype == PredicateType.AT_TIME:
                # AT_TIME(entity, property, value, time)
                # Contradiction if: same entity, same property, different value
                if len(existing.predicate.args) >= 3 and len(candidate.predicate.args) >= 3:
                    same_property = existing.predicate.args[1] == candidate.predicate.args[1]
                    diff_value = existing.predicate.args[2] != candidate.predicate.args[2]
                    if same_property and diff_value:
                        if self._scopes_overlap(existing.t_scope, candidate.t_scope):
                            contradictions.append(cid)
            
            elif ptype == PredicateType.HAS:
                # HAS(entity, property, value)
                # Contradiction if: same entity, same property, different value (functional)
                if len(existing.predicate.args) >= 3 and len(candidate.predicate.args) >= 3:
                    same_property = existing.predicate.args[1] == candidate.predicate.args[1]
                    diff_value = existing.predicate.args[2] != candidate.predicate.args[2]
                    # Check if property is functional (can only have one value)
                    if same_property and diff_value:
                        if self._is_functional_property(existing.predicate.args[1]):
                            if self._scopes_overlap(existing.t_scope, candidate.t_scope):
                                contradictions.append(cid)
            
            elif ptype == PredicateType.LOCATED_AT:
                # LOCATED_AT(entity, location, [time])
                # Contradiction if: same entity, different location, overlapping time
                if len(existing.predicate.args) >= 2 and len(candidate.predicate.args) >= 2:
                    diff_location = existing.predicate.args[1] != candidate.predicate.args[1]
                    if diff_location:
                        if self._scopes_overlap(existing.t_scope, candidate.t_scope):
                            contradictions.append(cid)
            
            elif ptype == PredicateType.SAME_AS:
                # SAME_AS is reflexive and transitive - complex handling
                # For now, flag if contradictory identity claims
                if len(existing.predicate.args) >= 2 and len(candidate.predicate.args) >= 2:
                    # A=B and A≠B would contradict, but we don't track negation yet
                    pass
        
        return contradictions
    
    def _is_functional_property(self, prop: str) -> bool:
        """
        Check if a property is functional (can only have one value at a time).
        
        E.g., "release_date" is functional, "feature" is not.
        """
        functional_props = {
            "release_date", "released", "born", "died", "founded",
            "ceo", "president", "capital", "population", "price",
            "state", "status", "location", "address",
        }
        return prop.lower() in functional_props
    
    def _scopes_overlap(self, scope1: TemporalScope, scope2: TemporalScope) -> bool:
        """Check if two temporal scopes overlap."""
        # If either is unbounded, assume overlap
        if not scope1.is_bounded or not scope2.is_bounded:
            return True
        
        # TODO: Proper interval overlap logic
        return True
    
    def _check_scope(
        self, 
        state: SymbolicState, 
        candidate: CandidateCommitment
    ) -> Tuple[bool, str]:
        """
        Check if the candidate's scope is valid.
        
        Returns (is_valid, reason_if_invalid)
        """
        # Functional predicates require bounded scope
        functional_predicates = {
            PredicateType.HAS, 
            PredicateType.LOCATED_AT,
            PredicateType.AT_TIME,
        }
        
        if candidate.predicate.ptype in functional_predicates:
            if not candidate.t_scope.is_bounded and candidate.sigma > 0.5:
                return False, "FUNCTIONAL_REQUIRES_SCOPE"
        
        return True, ""
    
    def _mint_commitment(
        self, 
        candidate: CandidateCommitment,
        support_mass: float,
        support_deficit: float,
    ) -> Commitment:
        """Mint a real commitment from an accepted candidate."""
        import uuid
        
        commitment_id = f"φ_{uuid.uuid4().hex[:12]}"
        
        # Convert dependency IDs to Dependency objects
        logical_deps = [
            Dependency(source_id=dep_id, dep_type=DependencyType.LOGICAL)
            for dep_id in candidate.logical_deps
        ]
        evidentiary_deps = [
            Dependency(source_id=dep_id, dep_type=DependencyType.EVIDENTIARY)
            for dep_id in candidate.evidentiary_deps
        ]
        
        return Commitment(
            commitment_id=commitment_id,
            predicate=candidate.predicate,
            sigma=candidate.sigma,
            t_scope=candidate.t_scope,
            provclass=candidate.provclass,
            support=list(candidate.support),
            logical_deps=logical_deps,
            evidentiary_deps=evidentiary_deps,
            status="active",
            support_mass=support_mass,
            support_deficit=support_deficit,
        )


# =============================================================================
# Demo / Sanity Check
# =============================================================================

if __name__ == "__main__":
    print("=== Symbolic Substrate V2 Demo ===\n")
    
    # Create state
    state = SymbolicState()
    adjudicator = Adjudicator()
    
    # Register entities
    state.register_entity("alice", {"type": "person"})
    state.register_entity("room1", {"type": "location"})
    
    # Create a candidate commitment
    candidate = CandidateCommitment(
        predicate=Predicate(
            ptype=PredicateType.LOCATED_AT,
            args=("alice", "room1"),
        ),
        sigma=0.8,  # High confidence
        t_scope=TemporalScope(
            start=datetime(2025, 1, 1, 10, 0),
            end=datetime(2025, 1, 1, 10, 0),
            granularity="instant",
        ),
        provclass=ProvenanceClass.CITED,
        support=[
            SupportItem(
                source_type="doc_span",
                source_id="doc_A",
                reliability=0.9,
            ),
            SupportItem(
                source_type="citation",
                source_id="example.com/page1",
                reliability=0.7,
            ),
        ],
    )
    
    # Adjudicate
    result = adjudicator.adjudicate(state, candidate)
    
    print(f"Decision: {result.decision.name}")
    print(f"Support mass computed: {result.support_mass_computed:.3f}")
    print(f"Support mass required: {result.support_mass_required:.3f}")
    print(f"Support deficit: {result.support_deficit:.3f}")
    print(f"Reason: {result.reason_code}")
    
    if result.commitment:
        print(f"\nMinted commitment: {result.commitment.commitment_id}")
        state.add_commitment(result.commitment)
        print(f"Total sigma allocated: {state.total_sigma_allocated}")
    
    # Try a high-sigma claim without enough support
    print("\n--- Testing support deficit ---")
    weak_candidate = CandidateCommitment(
        predicate=Predicate(
            ptype=PredicateType.HAS,
            args=("alice", "occupation", "engineer"),
        ),
        sigma=0.9,  # Very high confidence
        t_scope=TemporalScope(),  # Unknown scope
        provclass=ProvenanceClass.MODEL,  # Model-generated (low trust)
        support=[],  # No support!
    )
    
    result2 = adjudicator.adjudicate(state, weak_candidate)
    print(f"Decision: {result2.decision.name}")
    print(f"Support required: {result2.support_mass_required:.3f}")
    print(f"Support provided: {result2.support_mass_computed:.3f}")
    print(f"Reason: {result2.reason_code}")
